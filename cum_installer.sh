#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup (using post-commit hook)..."
echo "Script execution started at: $(date)" # Current date will be used here

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt-get &> /dev/null; then # Changed from apt to apt-get for wider compatibility
      sudo apt-get update && sudo apt-get install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt-get, yum, brew) found. Please install $package manually."
      exit 1
    fi

    if ! command -v "$package" &> /dev/null; then
        echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
        exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl" # curl is needed for API communication
echo "Checkpoint 3: Required packages checked/installed."

CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}      % For colored text
\\usepackage{courier}      % For pcr font family
\\usepackage{xurl}         % For better URL handling
\\usepackage{minted}       % For syntax highlighting (optional, but good for code diffs)
\\usepackage{geometry}     % For page layout
\\geometry{a4paper, margin=1in}

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section. If a file's diff is large, its summary might be generated from multiple parts.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."

# 4. Define and install the post-commit hook
HOOK_PATH="$GIT_ROOT/.git/hooks/post-commit"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

# Remove old pre-push hook if it exists from previous installations of this tool
OLD_PRE_PUSH_HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
if [ -f "$OLD_PRE_PUSH_HOOK_PATH" ]; then
    if grep -q "CUM pre-push hook" "$OLD_PRE_PUSH_HOOK_PATH" 2>/dev/null; then # Simple check, suppress grep errors
        echo "‚ÑπÔ∏è Removing old CUM pre-push hook at $OLD_PRE_PUSH_HOOK_PATH."
        rm -f "$OLD_PRE_PUSH_HOOK_PATH"
    fi
fi

echo "‚öôÔ∏è  Attempting to install post-commit hook to: $HOOK_PATH"
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

echo "Checkpoint 10: About to write post-commit hook content to $HOOK_PATH."
# This heredoc writes the actual post-commit hook script
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Prevent the hook from running when we are amending the commit from within this hook
if [ "$GIT_CUM_REPORT_AMENDING_COMMIT" = "true" ]; then
  exit 0
fi

# Hook script strict mode
set -e
set -o pipefail

echo "üî• Running CUM post-commit hook (commit details as blue paragraph)..."

GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

# Check if the LaTeX log file exists, if not, recreate it.
if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ö†Ô∏è Hook Warning: LaTeX log file not found at $TEX_FILE_PATH. Recreating it." >&2
    mkdir -p "$(dirname "$TEX_FILE_PATH")"
    # This template must match the one in the main installation script
    cat << EOF_INNER > "$TEX_FILE_PATH"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{xcolor}      % For colored text
\\usepackage{courier}      % For pcr font family
\\usepackage{xurl}         % For better URL handling
\\usepackage{minted}       % For syntax highlighting (optional)
\\usepackage{geometry}     % For page layout
\\geometry{a4paper, margin=1in}

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit. Each commit is a section, and each modified file within that commit is presented as a subsection with its AI-generated summary. Commit details are provided at the end of each section. If a file's diff is large, its summary might be generated from multiple parts.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each main section corresponds to a single Git commit. Within each commit section, individual subsections detail the AI-generated summary for each modified file. Key details about the commit (hash, author, date) are listed at the end of each section's content.
\\end{document}
EOF_INNER
    if [ $? -ne 0 ]; then
        echo "‚ùå Hook Error: Failed to recreate LaTeX log file at $TEX_FILE_PATH. Summary will not be added." >&2
        exit 0 # Exit gracefully from hook if TeX file can't be made
    fi
    echo "‚úÖ LaTeX log file recreated at $TEX_FILE_PATH."
fi

commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an' HEAD)
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local HEAD)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

changed_files_str=""
is_initial_commit=false
if ! git rev-parse --verify HEAD^ >/dev/null 2>&1; then
    is_initial_commit=true
fi

if $is_initial_commit; then
    echo "üìù Initial commit detected. Listing all files in the commit."
    changed_files_str=$(git diff-tree --no-commit-id --name-only -r HEAD)
else
    echo "üìù Standard commit. Listing changed files against HEAD^."
    changed_files_str=$(git diff --name-only HEAD^ HEAD)
fi

# Using /v1/completions endpoint
VLLM_API_URL="http://10.16.246.2:8001/v1/completions"
MODEL_NAME="TheBloke/CodeLlama-13B-Instruct-AWQ" # This is for the 'model' field in JSON
MAX_TOKENS_PER_FILE=1000 # Max tokens for *each chunk's summary*
MAX_DIFF_CHARS_PER_FILE=12000 # Limit characters in diff sent to LLM per request

all_files_latex_subsection_blocks=""

OLD_IFS="$IFS"
IFS=$'\n'
changed_files_array=()
while IFS= read -r line; do
    if [[ -n "$line" ]]; then # Only add non-empty lines
        changed_files_array+=("$line")
    fi
done <<< "$changed_files_str"
IFS="$OLD_IFS"


if [ ${#changed_files_array[@]} -eq 0 ] && [ -n "$changed_files_str" ]; then
    echo "‚ö†Ô∏è Warning: Changed files string was not empty but parsed to zero files. Check for unusual filenames or only whitespace."
fi

for file_path in "${changed_files_array[@]}"; do
    if [ -z "$file_path" ]; then
        continue
    fi

    echo "üìÑ Processing file: $file_path"
    file_diff_output_raw=""

    if $is_initial_commit; then
        if git show "HEAD:$file_path" &>/dev/null; then
            file_diff_output_raw=$(git show "HEAD:$file_path")
        else
            echo "   ‚ÑπÔ∏è File $file_path listed in initial commit tree but 'git show' failed (possibly removed before first commit or unusual state)."
            file_diff_output_raw="File content not available for initial commit summary."
        fi
    else
        file_diff_output_raw=$(git diff HEAD^ HEAD -- "$file_path")
    fi

    escaped_file_path_for_latex=$(printf '%s\n' "$file_path" | sed 's/\\/\\textbackslash{}/g; s/{/\\{/g; s/}/\\}/g; s/\$/\\\$/g; s/&/\\&/g; s/#/\\#/g; s/_/\\_/g; s/%/\\%/g; s/~/\textasciitilde{}/g; s/\^/\\^{}/g')

    if [ -z "$file_diff_output_raw" ]; then
        echo "   ‚ÑπÔ∏è No textual changes found for $file_path or content unavailable. Skipping API call."
        all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\nNo textual changes detected in this file for this commit.\n\n"
        continue
    fi

    # Sanitize (remove backspace, form feed)
    sanitized_file_diff=$(echo "$file_diff_output_raw" | tr -d '\b\f')
    sanitized_file_diff_len=$(echo -n "$sanitized_file_diff" | wc -c)

    final_summary_for_file_parts="" # This will hold the combined summaries for the file

    if [ "$sanitized_file_diff_len" -eq 0 ]; then
        echo "   ‚ÑπÔ∏è No textual changes found for $file_path after sanitization. Skipping API call."
        file_summary_text_escaped_for_latex="No textual changes detected in this file for this commit (after sanitization)."
    else
        num_chunks=$(( (sanitized_file_diff_len + MAX_DIFF_CHARS_PER_FILE - 1) / MAX_DIFF_CHARS_PER_FILE ))
        if [ "$num_chunks" -eq 0 ]; then # Should ideally not happen if sanitized_file_diff_len > 0
            num_chunks=1
        fi

        current_offset=0
        echo "   ‚ÑπÔ∏è Diff length for $file_path is $sanitized_file_diff_len bytes. Will be processed in $num_chunks chunk(s)."

        for (( chunk_num=1; chunk_num<=num_chunks; chunk_num++ )); do
            # Calculate length of current chunk
            chunk_length=$MAX_DIFF_CHARS_PER_FILE
            if (( current_offset + chunk_length > sanitized_file_diff_len )); then
                chunk_length=$((sanitized_file_diff_len - current_offset))
            fi

            # Extract chunk using bash substring expansion (byte-based)
            file_diff_chunk="${sanitized_file_diff:$current_offset:$chunk_length}"

            part_indicator=""
            if [ "$num_chunks" -gt 1 ]; then
                part_indicator=" (Part $chunk_num of $num_chunks)"
            fi

            # Construct prompt for this chunk
            user_prompt_content="File: '$file_path' (Commit: $commit_short_hash)${part_indicator}. "
            user_prompt_content+="Summarize the following code changes. Explain what the changes likely achieve at a high level and their potential impact or purpose. Be concise."
            if [ "$num_chunks" -gt 1 ]; then
                if [ "$chunk_num" -lt "$num_chunks" ]; then
                    user_prompt_content+=" This is part $chunk_num of $num_chunks of the diff. Please summarize this part. More content will follow."
                else # Last chunk
                    user_prompt_content+=" This is the final part ($chunk_num of $num_chunks) of the diff. Please summarize this concluding part, considering any previous context if applicable."
                fi
            fi
            user_prompt_content+=$'\n\nDiff part:\n\n'"$file_diff_chunk"

            formatted_prompt_for_completion="<s>[INST] $user_prompt_content [/INST]"

            echo "   üìû Contacting LLM API for $file_path (Part $chunk_num/$num_chunks, ${#file_diff_chunk} chars)..."
            payload_file_chunk=$(jq -n \
                --arg model_name "$MODEL_NAME" \
                --arg formatted_prompt "$formatted_prompt_for_completion" \
                --argjson max_tokens "$MAX_TOKENS_PER_FILE" \
                '{ model: $model_name, prompt: $formatted_prompt, max_tokens: $max_tokens, stream: false, temperature: 0.7, top_p: 0.95 }')

            summary_text_for_this_chunk=""
            if [ $? -ne 0 ]; then
                echo "   ‚ùå Hook Error: Failed to construct JSON payload for $file_path (Part $chunk_num/$num_chunks)." >&2
                summary_text_for_this_chunk="Automated summary generation failed for this part: Error constructing API payload."
            else
                api_response_file_stderr_chunk=$(mktemp)
                api_response_file_chunk=$(echo "$payload_file_chunk" | curl --silent --fail --show-error -X POST \
                    -H "Content-Type: application/json" -d @- \
                    --connect-timeout 20 --max-time 180 "$VLLM_API_URL" 2> "$api_response_file_stderr_chunk")
                curl_exit_status_file_chunk=$?

                if [ $curl_exit_status_file_chunk -ne 0 ]; then
                    echo "   ‚ùå Hook Warning: LLM API request failed for $file_path (Part $chunk_num/$num_chunks) (curl code: $curl_exit_status_file_chunk)." >&2
                    if [ -s "$api_response_file_stderr_chunk" ]; then
                        echo "   Curl STDERR:" >&2
                        cat "$api_response_file_stderr_chunk" >&2
                    fi
                    # Log the payload that was sent for easier debugging, but not the whole diff chunk in it
                    echo "   Failed Prompt (first 300 chars of formatted prompt): $(echo "$formatted_prompt_for_completion" | head -c 300)..." >&2
                    summary_text_for_this_chunk="Automated summary generation failed for this part: LLM API request error (curl code: $curl_exit_status_file_chunk)."
                else
                    if echo "$api_response_file_chunk" | jq -e '.choices[0].text' > /dev/null 2>&1; then
                        extracted_text_chunk=$(echo "$api_response_file_chunk" | jq -r '.choices[0].text')
                        summary_text_for_this_chunk="$extracted_text_chunk"
                        echo -e "   ‚úÖ Summary for $file_path (Part $chunk_num/$num_chunks) received."
                    else
                        echo "   ‚ùå Hook Warning: Failed to extract summary text for $file_path (Part $chunk_num/$num_chunks) from response." >&2
                        echo "   Raw API Response for $file_path Part $chunk_num: $api_response_file_chunk" >&2
                        summary_text_for_this_chunk="Automated summary generation failed for this part: Could not parse LLM response."
                    fi
                fi
                rm -f "$api_response_file_stderr_chunk" # Clean up temp file
            fi

            if [ "$num_chunks" -gt 1 ]; then
                # Add a header for each part's summary if there are multiple parts
                 final_summary_for_file_parts+="{\\bfseries Summary for Diff Part $chunk_num of $num_chunks:}\\par\n$summary_text_for_this_chunk\n\n"
            else
                final_summary_for_file_parts+="$summary_text_for_this_chunk"
            fi

            current_offset=$((current_offset + chunk_length))
        done # end of chunk loop

        # Escape the accumulated summary for LaTeX
        file_summary_text_escaped_for_latex=$(echo -n "$final_summary_for_file_parts" | sed 's/\f//g' | sed \
            -e 's/\\/\\textbackslash{}/g' -e 's/{/\\{/g'  -e 's/}/\\}/g' \
            -e 's/\$/\\\$/g' -e 's/&/\\&/g' -e 's/#/\\#/g'  -e 's/_/\\_/g' \
            -e 's/%/\\%/g'  -e 's/~/\textasciitilde{}/g' -e 's/\^/\\^{}/g' \
            -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' -e 's/-/--/g')
    fi # end of if sanitized_file_diff_len -eq 0 check

    all_files_latex_subsection_blocks+="\\subsection{File: \\texttt{$escaped_file_path_for_latex}}\n{\\fontfamily{pcr}\\selectfont\n$file_summary_text_escaped_for_latex\n}\n\n"
done


file_summaries_section_content=""
if [ ${#changed_files_array[@]} -eq 0 ]; then
    message=""
    if [ -z "$changed_files_str" ]; then # No files changed at all
        message="No files were part of this commit (e.g., an empty commit). No AI summaries generated."
    else # Files string existed but parsed to empty array (e.g. only whitespace in string)
        message="Could not parse the list of changed files, or only files with non-textual changes were present. No AI summaries generated."
    fi
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
elif [ -z "$all_files_latex_subsection_blocks" ]; then # Should not happen if array has items, unless all items resulted in error or no textual change
    message="No textual changes found in modified files for AI summary, or summary generation failed for all relevant files."
    file_summaries_section_content="\\subsection{File Change Summaries}\n$message\n"
else
    file_summaries_section_content="$all_files_latex_subsection_blocks"
fi

escaped_commit_author=$(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g') # Basic LaTeX escaping for author
escaped_commit_date=$(echo "$commit_date" | sed 's/_/\\_/g') # Basic LaTeX escaping for date
# More robust title escaping, especially for author names with special LaTeX chars
section_title_raw="Commit $commit_short_hash by $commit_author ($commit_date)"
section_title=$(echo "$section_title_raw" | sed \
    -e 's/\\/\\textbackslash{}/g' -e 's/{/\\{/g'  -e 's/}/\\}/g' \
    -e 's/\$/\\\$/g' -e 's/&/\\&/g' -e 's/#/\\#/g'  -e 's/_/\\_/g' \
    -e 's/%/\\%/g'  -e 's/~/\textasciitilde{}/g' -e 's/\^/\\^{}/g' )


commit_details_paragraph=""
commit_details_paragraph+="{\\color{blue}\\small % Start color blue and make text small\n"
commit_details_paragraph+="Commit: \\texttt{$commit_hash} \\\\\n"
commit_details_paragraph+="Author: \\texttt{$(echo "$commit_author" | sed 's/[&%$_#^]/\_&/g; s/_/\\_/g; s/{/\\{/g; s/}/\\}/g')}\\\\\n" # More escaping for author in details
commit_details_paragraph+="Date: \\texttt{$(echo "$commit_date" | sed 's/_/\\_/g')}\n"
commit_details_paragraph+="} % End color blue\n"

section_content="\\section{$section_title}
$file_summaries_section_content
$commit_details_paragraph
\\hrulefill
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"

export CUM_REPORT_AWK_SECTION_CONTENT="$section_content"
# Use a temporary file for awk script to handle potential complex characters in section_content
awk_script_file=$(mktemp)
# Ensure ENVIRON is available or pass via -v var="$var"
# Using ENVIRON is generally fine for most awk versions.
echo '/\\end\{document\}/{printf "%s\n", ENVIRON["CUM_REPORT_AWK_SECTION_CONTENT"]}1' > "$awk_script_file"

awk -f "$awk_script_file" "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?
rm -f "$awk_script_file" # Clean up awk script file
unset CUM_REPORT_AWK_SECTION_CONTENT

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summaries for commit $commit_short_hash appended to $TEX_FILE_PATH"
        echo " amending commit to include TeX log update..."
        git add "$TEX_FILE_PATH"
        export GIT_CUM_REPORT_AMENDING_COMMIT=true
        # Use --no-verify to prevent other hooks (like pre-commit, commit-msg) from running during amend
        git commit --amend --no-edit -C HEAD --no-verify
        unset GIT_CUM_REPORT_AMENDING_COMMIT
        echo "‚úÖ Commit amended to include TeX log update."
    else
        echo "‚ùå Hook Warning: Failed to move temporary TeX file. TeX log not updated." >&2
        rm -f "$TMP_TEX_FILE" # Clean up temp tex file on error
    fi
else
    echo "‚ùå Hook Warning: Failed to write summary to TeX file using awk (status: $awk_status). TeX log not updated." >&2
    rm -f "$TMP_TEX_FILE" # Clean up temp tex file on error
fi

echo "‚úÖ CUM post-commit hook (commit details as blue paragraph) finished for $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF
# End of heredoc for the hook script

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write post-commit hook script content to $HOOK_PATH." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo ""
echo "üéâ CUM Report setup complete with a post-commit hook!"
echo "‚ÑπÔ∏è  The hook is now configured to send requests to your vLLM API using the /v1/completions endpoint at: $VLLM_API_URL"
echo "    for model: $MODEL_NAME"
echo "    Prompts are formatted with '<s>[INST] ... [/INST]'."
echo "    Diffs larger than $MAX_DIFF_CHARS_PER_FILE characters will be split into multiple requests."
echo "‚ÄºÔ∏è IMPORTANT: Ensure your vLLM server at $VLLM_API_URL is running and"
echo "    is serving the model '$MODEL_NAME' (or the name it expects for it)."
echo ""
echo "After each 'git commit', the summary will be generated and the commit will be amended to include the changes to '$INITIAL_TEX_FILE'."
echo "Your working directory should remain clean regarding this file after a commit."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo "Consider running 'pdflatex' twice for table of contents and cross-references to be correct."
echo ""
echo "If the hook doesn't run after 'git commit', check 'git config core.hooksPath'."
echo "If 'core.hooksPath' is set to something other than '.git/hooks', you may need to manually place the hook there."
echo "Script execution finished at: $(date)" # Current date will be used here

exit 0